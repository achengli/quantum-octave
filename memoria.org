#+TITLE:     Modulacion de pulsos correlados
#+SUBTITLE:  Practica 1 de Comunicaciones Digitales
#+AUTHOR:    Yassin Achengli
#+DATE:      {{{time(%Y-%m-%d)}}}

#+DESCRIPTION: Diseno de pulsos de transmision, implementacion de las constelaciones PAM y QAM, y la influencia de los parametros.
#+KEYWORDS:  QAM, PAM, Comunicaciones, Digitales
#+include: ./headers.org

* Modulacion de pulsos
#+begin_verse
En un sistema de comunicaciones, la transmision de la informacion tiene como base el uso de pulsos
como medio, estos pulsos pueden ser variaciones del nivel de energia en el tiempo, variaciones de
la frecuencia o incluso de la fase.

Nos vamos a focalizar en la manera en la que estos pulsos son transmitidos y recibidos, como pueden
ser multiplexados en un mismo canal sin que se pierda la informacion que transportan.
lp
El concepto de independencia entre pulsos es el factor que se explota para conseguir esta
caracteristica, para ello elaboramos la operacion correlacion de pulsos para el cual, si tenemos
dos pulsos independientes, su correlacion ha de ser nula
#+end_verse

#+begin_export latex
\begin{equation} \label{eq:1}
\langle x(t),y(t)\rangle = \int_{-\infty}^{\infty} x(t)\cdot y^*(t) dt
\end{equation}
#+end_export

#+begin_verse
Se han elaborado dos funciones en Matlab para llevar a cabo la operacion de correlacion de pulsos.
En primer lugar se ha realizado la funcion =correlation=, y seguidamente tambien se ha elaborado la
funcion =Correlator= /"vease la cita *1.1* y *1.2* respectivamente"/ que hace uso de =correlation=
para hacer la correlacion de una secuencia de pulsos recibidos con un pulso singular para obtener
los simbolos transmitidos.
#+end_verse

#+NAME: cita 1.1
#+ATTR_LATEX: :width 0.5\textwidth
#+begin_src octave :results silent :exports code
% Función que calcula la correlación de dos vectores fila de
% la misma longitud.
% La cabecera es:
%   c=correlation(x,y)
% donde:
% c ............. correlación de x e y
% x,y ........... vectores fila de la misma longitud
%
function c=correlation(x,y)
    x = reshape(x, 1, length(x));
    if (length(x) ~= length(y)) % ambos vectores deben tener el mismo tamaño
        print_usage();
    end
    y = reshape(y,size(x)).';
    c = x*y;
end

%!test
%! assert(correlation([1 -1 1 -1],[1 1 1 1]) == 0)
%! assert(correlation([1 -1 1 -1],[-1 1 -1 1]) == -4)
#+end_src
#+begin_center
/Cita 1.1. Funcion correlation/
#+end_center

#+NAME: cita 1.1
#+ATTR_LATEX: :width 0.5\textwidth
#+begin_src octave :results silent :exports code
% Función que calcula la correlación de un pulso con la secuencia
% de pulsos de una señal recibida para obtener los símbolos
% recibidos
% La cabecera es:
%
% ar=Correlator(Pulse,M,xr)
% donde:
% ar ............ vector de simbolos obtenidos de la correlación
% Pulse ......... vector de muestras del pulso
% M ............. número de muestras de un periodo de símbolo
% xr ............ vector de muestras de la señal recibida
%
function ar=Correlator(Pulse,M,xr)
    ar = [];
    lP = length(Pulse);

    if (mod((length(xr) - lP),M) ~= 0) % Esta condicion revisa que efectivamente se estan
        print_usage();                 % transmitiendo M simbolos en la secuencia de pulsos
    end

    for i = [1:M:length(xr)-lP+1]
        buff = xr(i:i+lP-1);
        ar = [ar, correlation(Pulse,buff)];
    end
end

%!demo
%! load SignalPulse.mat;
%! ar = Correlator(Pulse,M,xr)
#+end_src
#+begin_center
/Cita 1.2. Funcion Correlator/
#+end_center

#+begin_verse
Podemos ver el funcionamiento del correlador usando el ejemplo que aparece en los comentarios que
comienzan con la cabecera /"%!demo"/ y donde cada linea debe comenzar con /"%!"/. Para llamar a
estas secciones de ejemplo se usa la funcion =demo=.

En las citas *1.3.* y *1.4.* se puede ver el resultado de las demostraciones de las funciones con
un set de datos proporcionado en el paquete de utilidades de la practica.
#+end_verse

#+begin_src octave :results output
printf("Demostracion de la funcion correlation\n---\n");
demo correlation
printf("\nDemostracion de la funcion Correlator\n---\n")
demo Correlator
#+end_src
#+begin_center
/Cita 1.3. Código de demostracion/
#+end_center

** Resultado de la demostracion
#+RESULTS:
#+begin_example
Demostracion de la funcion correlation
---
 correlation([1 -1 1 -1],[1 1 1 1])
 correlation([1 -1 1 -1],[-1 1 -1 1])

ans = 0
ans = -4

Demostracion de la funcion Correlator
---
 load SignalPulse.mat;
 ar = Correlator(Pulse,M,xr)

ar =

   1.5000  -0.5000   1.5000  -0.5000  -1.5000   0.5000
#+end_example
#+begin_center
/Cita 1.4. Resultado de las demostraciones/
#+end_center

* Sistema Transmisor/Receptor
#+begin_verse
Tras haber elaborado las anteriores funciones comentadas en el apartado previo, se ha hecho uso de un
sistema construido sobre Matlab cuyo codigo tambien ha sido proporcionado dentro del set de utilidades.

Este sistema esta hecho para ser configurable y lo usaremos para mostrar los efectos de distintos
fenomenos sobre el canal /(Forma del pulso empleado y la probabilidad de error)/, y sobre la
constelacion empleada.

En la figura *2.1* hay una representacion total y suficientemente definida para entender el funcionamiento
del sistema del que haremos uso.
#+end_verse

#+CAPTION: Figura 2.1.
#+DESCRIPTION: Sistema Transmisor/Receptor
[[./P1ComDig/assets/sist.png]]
#+begin_center
/Figura 2.1. Sistema Transmisor/Receptor/
#+end_center

#+begin_verse
Dentro del transmisor hay tres bloques, el generador de bits que es el que genera la informacion, el
mapeador que asigna un simbolo cada secuencia de $b$ bits, estos bits son los necesarios para
codificar los simbolos de la constelacion usada y depende de $M$ que es el numero de simbolos de la
constelacion $b = log_2(M)$. Tras el mapeador se da forma a los pulsos segun el pulso a transmitir.

El transmisor prosigue enviando la secuencia de simbolos al canal. El canal tiene ciertos parametros
alteran el funcionamiento del sistema y son la probabilidad de error de simbolo *SER* /(Simbol Error
Rate)/ y *BER* /(Bit Error Rate)/. Estos parametros dependen directamente del nivel de ruido que se
mide a partir del *SNR* /(Signal Noise Rate)/ que mide la relacion entre en nivel de energia de
señal sobre el de ruido.

Finalmente tenemos el receptor que realiza la operacion inversa a la del transmisor. Hace uso de la
correlacion del pulso con los pulsos recibidos para obtener asi el /peso/ de los simbolos recibidos
de tal forma que un pulso consigo mismo tiene una correlacion 1
#+end_verse

#+begin_export latex
\begin{equation} \label{eq:2}
\langle x(t),x(t) \rangle = \int_{-\infty}^{\infty} x(t)\cdot x^*(t) dt
\end{equation}
#+end_export

#+begin_verse
Se puede apreciar que la operacion $x(t)\cdot x^*(t)$ es equivalente al modulo al cuadrado de $x(t)$
#+end_verse

#+begin_export latex
\begin{equation} \label{eq:3}
x(t)\cdot x^*(t) \equiv \lvert x(t)\rvert^2
\end{equation}
#+end_export

#+begin_verse
Si suponemos que usamos un pulso recibido $x_r(t) = A\cdot p(t)$ que es la amplitud del simbolo
multiplicado por el pulso y lo correlamos con $p(t)$, haciendo uso de la ecuacion /*(3)*/ obtenemos
#+end_verse

#+begin_export latex
\begin{equation} \label{eq:4}
x_r(t)\cdot p^*(t) = A\cdot p(t)\cdot p^*(t) = A\cdot\lvert p(t)\rvert^2
\end{equation}
#+end_export

#+begin_verse
Al ser pulsos normalizados se puede afirmar que $\lvert p(t)\rvert = 1$, y en consecuencia si hacemos su
correlacion usando la ecuacion /*(2)*/ tenemos
#+end_verse

#+begin_export latex
\begin{equation} \label{eq:5}
\langle A\cdot x(t),p(t)\rangle = \int_{-\infty}^{\infty} A\cdot \lvert p(t)\rvert^2 dt = A
\end{equation}
#+end_export

#+begin_verse
Esto ocurre en el caso ideal, en la realidad el canal introduce un ruido que generalmente es blanco
/"blanco quiere decir de media 0"/, y por ello se necesita un decisor que realiza la eleccion
del simbolo que se transmitio minimizando el *SER*.
#+end_verse

** Forma del pulso
#+begin_verse
El pulso empleado para estas demostraciones es un pulso rectangular. Ejecutando el script
*SystModPulse.m* obtenemos varias representaciones graficas del mismo, entre ellas esta una muestra
temporal de la señal transmitida, la autocorrelacion del pulso o la *DEP* /(Densidad Espectral de
Potencia)/ estimada entre otras. En la figura *3.1* se puede ver la *DEP* de la señal transmitida
donde el eje de frecuencias esta multiplicado por $f_s$. Se puede apreciar el ancho de banda de
$2kHz$ del lobulo principal.
#+end_verse

#+CAPTION: Figura 3.1.
#+DESCRIPTION: Estimacion de la DEP
[[./P1ComDig/assets/3.6.1/ancho_de_banda_aprox.jpg]]
#+begin_center
/Figura 3.1. Estimacion de la DEP del pulso transmitido/
#+end_center

#+CAPTION: Figura 3.2.
#+DESCRIPTION: Señal transmitida
[[./P1ComDig/assets/3.6.1/autocorr1.png]]
#+begin_center
/Figura 3.2. Señal transmitida/
#+end_center

#+begin_quote
Se puede comprobar viendo la grafica de la figura *3.1.* que el ancho de banda del espectro de
la señal transmitida en una caida de $20 dB$ es de $5.4f_s$ aproximadamente atendiendo a los
marcadores que hay situados en la grafica mencionada; Los puntos estan distanciados a
$(2.68 - (-2.57))\cdot f_s = 5.25\cdot f_s$

(*) Ten en cuenta que a pesar de que no se vea bien el eje de frecuencias, cada unidad equivale
a $f_s$ /(frecuencia de simbolo)/.

Apreciando la forma de la estimacion de la *DEP*, se puede razonar que su forma esta
condicionada por la forma de la transformada de fourier del pulso que en este caso al ser
un pulso rectangular, su transformada de fourier seria una /sinc/ con un lobulo principal que
ocupa una banda de frecuencias $f_s$ y con unos lobulos secundarios bastante atenuados;
es practicamente lo que resulta de la estimacion de la *DEP* solo que esta ademas presenta
el resultado del efecto del ruido del canal sobre la señal transmitida.
#+end_quote

#+begin_quote
En la figura *3.2.* se puede observar que los pulsos transmitidos no se solapan, esto se debe
a que la duracion de los pulsos es la misma que el periodo de simbolo. Si el periodo de
simbolo fuese menor que la duracion del pulso, entonces si habria un solapamiento y dependiendo
del receptor, se podria o no corregir esa interferencia.
#+end_quote

** Efecto del pulso raiz de coseno alzado
#+begin_verse
A partir del script *SystModPulse.m* se ha creado un derivado con las modificaciones oportunas
que aparecen en la cita /*3.1*/ para asi transmitir pulsos raiz de coseno alzado con los
siguientes parametros

\begin{itemize}
\item \alpha = $0.8$
\item Longitud del pulso $10$
\item Sobremuestreo $16$
\end{itemize}
#+end_verse

#+NAME: Cita 3.1
#+begin_src octave :exports code :results none
PulseType='RootRaisedCosine';
% Factor de forma y longitud del pulso (en periodos de símbolo) para pulsos
% raíz de coseno alzado
Alpha=0.8;
Long=10;
% Factor de sobremuestreo para simular señales continuas (muestras por periodo de símbolo)
Oversampled=16;
#+end_src
#+begin_center
/Cita 3.1. Cambios sobre SystModPulse.m entre las lineas 35 y 41/
#+end_center

#+NAME: Figura 3.3.
[[./P1ComDig/assets/3.6.2/espectro_pulso.jpg]]
#+begin_center
/Figura 3.3. Estimacion de la DEP transmitida para el pulso raiz coseno alzado, forma del pulso
y espectro del pulso/
#+end_center

#+NAME: Figura 3.4.
[[./P1ComDig/assets/3.6.2/autocorrelacion.jpg]]
#+begin_center
/Figura 3.4. Autocorrrelacion del pulso/
#+end_center


#+begin_quote
En este caso, el pulso tiene una longitud mayor que el periodo de simbolo, es notorio que habra
solapamiento de los pulsos en el dominio temporal, sin embargo hay que atender a la autocorrelacion
del pulso para ver que si se muestrea cada periodo de simbolo, la muestra 0 es la que tiene mayor
peso y ademas de valor 1 /(No fuerza una atenuacion del simbolo)/, ademas, las muestras siguientes
correspondientes a simbolos de instantes temporales distintos tienen peso 0 por lo que realmente
no se solapan /(Son independientes)/.

La explicacion que se acaba de dar esta justificada por el resultado de la figura *3.4.*
que aparece justo encima
#+end_quote

#+begin_quote
Como se puede ver, el espectro de la señal transmitida posee un lobulo principal como paso con el
pulso cuadrado. El ancho del lobulo es el mismo que el del espectro del pulso. En la anchura del
pulso se puede determinar tambien como afecta el parametro \alpha en el exceso de ancho de banda;
calculando el ancho del lobulo principa viendo la figura *3.5.* y fijandonos en los marcadores,
veremos que es de $(0.9 - (-0.9))\cdot f_s = 1.8f_s$ de duracion, aproximadamente igual al parametro
\alpha multiplicado por la frecuencia de simbolo $f_s$.
#+end_quote

** Parametro \alpha del pulso raiz de coseno alzado
#+begin_verse
El parametro \alpha del pulso RCA /(Raiz de coseno Alzado)/ es un parametro de ajuste de la extension
del lobulo principal y de su forma.
#+end_verse

#+begin_export latex
\begin{itemize}
\item $0 \leq \alpha \leq 1 $
\item $\alpha\big\uparrow \rightarrow ancho del Pulso \big\uparrow$ , Forma del pulso mas redonda
\item $\alpha\big\downarrow \rightarrow ancho del Pulso \big\downarrow$ , Forma del pulso mas cuadrada
\end{itemize}
#+end_export

#+begin_quote
La anchura del lobulo principal excede la frecuencia de simbolo por el factor $\alpha\cdot f_s$, sin
embargo hay un factor mas destacable en este ejemplo y es en nivel que los lobulos secundarios tienen.
Ahora no estan tan atenuados y al hacer el pulso autocorrelado muestreado cada $f_s$ como vemos en la
figura *3.5*. Esto hace que el correlador no solo obtenga el valor del simbolo enviado sino tambien
parte de los simbolos anteriores empeorando el rendimiento lo que es causa directa de que en la figura
*3.6* la distribucion de simbolos no sea la misma que en el ejemplo anterior y se desvie de los simbolos
que existen.
#+end_quote

#+begin_verse
A pesar de todo se puede corregir este problema pero es tarea del decisor y este tiene limites para
establecer una decision correcta ademas de que sigue habiendo una probabilidad de error.
#+end_verse

#+NAME: Figura 3.5.
[[./P1ComDig/assets/3.6.3/autocorrelacion.jpg]]
#+begin_center
/Figura 3.5. Autocorrrelacion para un \alpha igual a $0.1$/
#+end_center

#+NAME: Figura 3.6.
[[./P1ComDig/assets/3.6.3/distribucion.jpg]]
#+begin_center
/Figura 3.6. Distribucion de los simbolos recibidos/
#+end_center

** Longitud del pulso

#+begin_verse
Veamos ahora que pasa si modificamos la longitud del pulso manteniendo los parametros vistos en el
apartado anterior.

La longitud del pulso es un factor determinante del ancho de banda del pulso por lo que una longitud
mayor tambien causa que su espectro este mas confinado y sus lobulos secundarios mas rebajados en
nivel por lo que tambien mejora el desempeño del correlador.

Hay que destacar tambien que la longitud del pulso tiene tambien su contraparte y es que se
necesita mas muestras para hacer la autocorrelacion y por ello mayor fuerza de computo que muchas
veces es un compromiso en algunos sistemas cuando tratamos de reducir el consumo.

Para este ejemplo hemos pasado de uan longitud de pulso de 10 muestras a 50 muestras creando un
nuevo script a partir de *SystModPulseRCC2.m* llamado *SystModPulseRCC3.m*.
#+end_verse

#+begin_quote
Ahora es importante resaltar que el pulso autocorrelado al tener mas muestras hemos conseguido que
en los intervalos $T_s$ las muestras sean de valor 0, o lo que es lo mismo, la autocorrelacion es
muy buena manteniendo la muestra 0 con un peso de 1 o cercano y el resto con un peso practicamente
nulo. No tendremos apenas efectos negativos causados por los simbolos transmitidos en instantes
anteriores /"ver la figura *3.7.*"/.
#+end_quote

#+NAME: Figura 3.7.
[[./P1ComDig/assets/3.6.4/autocorrelacion.jpg]]
#+begin_center
/Figura 3.7. Autocorrrelacion con un $\alpha 0.1$ y una longitud de pulso 50/
#+end_center

* Efecto de la variacion de la probabilidad de error
#+begin_verse
Hasta ahora hemos visto los efectos resultantes de variar parametros de parte del transmisor como
la longitud del pulso, el tipo de pulso o el sobremuestreo, ahora veremos como afecta el canal
sobre el modelo de comunicacion.

La probabilidad de error es la probabilidad de que habiendo transmitido $a$ recibimos $a'$ que
no es el mismo que el que se transmitio.

El error que tenemos es resultado de un error de simbolo que a su vez es causa de un error de bit.
El error de bit no es directamente proporcional al error de bit y depende de otros aspectos como
la forma en la que codificamos nuestros simbolos.
#+end_verse

** Comparacion de la SER teorica y simulada
#+begin_verse
La *SER* /(Simbol Error Rate)/ mide la tasa de error de simbolos, teoricamente tiene una
expresion para la constelacion PAM que es la que empleamos.
#+end_verse

\begin{equation}
SER_{teo} = 2\left(1 - \frac{1}{S}\right)\cdot Q\left(\sqrt{3\cdot\frac{SNR}{S^2-1}}\right)
\end{equation}

#+begin_verse
Donde $SNR$ es la relacion señal/ruido y $S$ es el numero de simbolos de la constelacion, al ser
la constelacion PAM, entonces $S = 2$.
#+end_verse

#+begin_verse
Para modelar el $SER$ teorico se ha incorporado una porcion de codigo al script *SystModPulse.m*
para mostrar el valor que resulta, esta porcion es la que aparece en la cita *3.2*.
#+end_verse

#+NAME: Cita 3.2.
#+begin_src octave :results none :exports code
Pn = Pa/snr;
SERt = 2*(1 - 1/S)*qfunc(sqrt(3*snr/(S^2 - 1)));
if strcmp(ModType,"QAM")
    SERt = 4*(1 - 1/sqrt(S))*qfunc(sqrt(3*snr/(S-1))) + ... % esto es para modulacion QAM
           (2*(1 - 1/sqrt(S))*qfunc(sqrt(3*snr/(S-1))))^2;  % que aparece mas adelante
end
fprintf("Error de simbolo: %.4f\n", SERt);
#+end_src
#+begin_center
/Cita 3.2. Seccion de codigo para calcular el $SER_{teorico}$/
#+end_center

#+begin_verse
La funcion =qfunc= es una implementacion de la funcion $Q$ estadistica que sirve para calcular
la densidad de probabilidad de una distribucion normal.
#+end_verse

#+begin_verse
Se ha modificado tambien algunos parametros base del sistema:

\begin{itemize}
\item Relacion señal/ruido $SNR = 7.5 dB$
\item Numero de simbolos $S = 2$
\end{itemize}
#+end_verse

#+begin_quote
Tras ejecutar el script podemos ver algunos resultados de interes, el $SNR_{teorico}$ es
practicamente el mismo que el $SNR_{sim}$ comparando los resultados puestos en la tabla *3.1.*

Tambien se puede ver el resultado de los simbolos decodificados en la figura *3.8.*. En este
caso se nota que hay un error notorio habiendo simbolos transmitidos erroneos en la recepcion.
#+end_quote

#+NAME: Figura 3.8.
[[./P1ComDig/assets/3.8.1/constelacion.jpg]]
#+begin_center
/Figura 3.8. Distribucion de los simbolos recibidos para $SNR = 7.5 dB$/
#+end_center

| SNR teorica         | SNR simulada        |
|---------------------+---------------------|
| $8.83\cdot 10^{-3}$ | $8.58\cdot 10^{-3}$ |
#+begin_center
/Tabla 3.1. Resultado de la $SNR$ teorica y simulada/
#+end_center


** Incremento del numero de simbolos y la SNR
#+begin_verse
Tomando el ejemplo anterior de partida y modificando la $SNR$ y el numero de simbolos de la
constelacion siendo ahora una $8-PAM$.

\begin{itemize}
\item $SNR = 20 dB$
\item $S = 8$
\end{itemize}
#+end_verse



* Conselaciones QAM
